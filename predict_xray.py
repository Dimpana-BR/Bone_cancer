import os
import cv2
import numpy as np
import joblib
import matplotlib.pyplot as plt
from sklearn.metrics import accuracy_score, confusion_matrix

# Use raw string literals or forward slashes for Windows paths to avoid
# invalid escape sequence warnings (e.g. '\\M' in 'D:\\MINI PROJECT').
svm_path = r'D:\MINI PROJECT\svm_model.pkl'
scaler_path = r'D:\MINI PROJECT\scaler.pkl'


def load_models(svm_file=None, scaler_file=None):
    """Load svm and scaler. Prefer local files in CWD, otherwise fall back to absolute paths.

    Returns:
        tuple: (svm, scaler)
    """
    # Prefer explicitly provided paths
    svm_file = svm_file or "svm_model.pkl"
    scaler_file = scaler_file or "scaler.pkl"

    # If local files exist in the current working directory, use them.
    if os.path.exists(svm_file) and os.path.exists(scaler_file):
        svm = joblib.load(svm_file)
        scaler = joblib.load(scaler_file)
        return svm, scaler

    # Otherwise try the configured absolute paths
    if os.path.exists(svm_path) and os.path.exists(scaler_path):
        svm = joblib.load(svm_path)
        scaler = joblib.load(scaler_path)
        return svm, scaler

    raise FileNotFoundError(
        f"Could not find svm/scaler. Checked: '{svm_file}', '{scaler_file}', '{svm_path}', '{scaler_path}'"
    )

def predict_xray(image_path, img_size=(64,64)):
    # Load image
    img = cv2.imread(image_path, cv2.IMREAD_GRAYSCALE)
    if img is None:
        raise ValueError("Could not read the image. Check the file path.")

    # Resize and flatten
    img_resized = cv2.resize(img, img_size)
    img_flatten = img_resized.flatten().reshape(1, -1)

    # Load models on demand (ensures we pick up models generated by the pipeline)
    svm, scaler = load_models()

    # Scale features
    img_scaled = scaler.transform(img_flatten)

    # Predict
    prediction = svm.predict(img_scaled)

    # image with prediction
    plt.imshow(img, cmap='gray')
    plt.title(f"Predicted: {prediction[0]}")
    plt.axis('off')
    plt.show()

    return prediction[0]


def predict_classical(X_test_scaled, y_test):
    """Predict using the pre-trained classical SVM model.

    Args:
        X_test_scaled (np.ndarray): Scaled feature matrix for testing.
        y_test (np.ndarray): True labels for the test set.

    Returns:
        tuple: (accuracy: float, y_pred: np.ndarray, cm: np.ndarray) or
               (None, None, None) on failure.
    """
    try:
        # Load the model that matches the simulated data that was just created
        svm, _ = load_models()

        # If X_test_scaled is not already scaled, this will still work but
        # it's expected that callers (like main.py) provide scaled features.
        y_pred = svm.predict(X_test_scaled)
        acc = accuracy_score(y_test, y_pred)
        cm = confusion_matrix(y_test, y_pred)
        print(f"Classical SVM accuracy: {acc:.4f}")
        return acc, y_pred, cm
    except Exception as e:
        print(f"Error during classical prediction: {e}")
        return None, None, None

# to predict with new image
def _main():
    # replace with your X-ray image path if needed
    image_path = r'D:\MINI PROJECT\images\stock-photo-bone-cancer-in-shoulder-444387289.jpg'
    if not os.path.exists(image_path):
        raise FileNotFoundError(f"Image not found at {image_path}")

    result = predict_xray(image_path)
    print(f"Prediction: {result}")


if __name__ == '__main__':
    _main()

